diff --git a/WolfWhisper/ContentView.swift b/WolfWhisper/ContentView.swift
index a34205f..7e1d725 100644
--- a/WolfWhisper/ContentView.swift
+++ b/WolfWhisper/ContentView.swift
@@ -6,13 +6,27 @@ struct ContentView: View {
     @StateObject private var audioService = AudioService.shared
     @StateObject private var transcriptionService = TranscriptionService.shared
     @StateObject private var hotkeyService = HotkeyService.shared
+    @State private var isWindowVisible = true
     
     var body: some View {
-        MainAppView(appState: appState)
+        MainAppView(appState: appState, isWindowVisible: isWindowVisible)
         .onAppear {
             setupServices()
             setupHotkey()
         }
+        .onDisappear {
+            // CRITICAL FIX: Clear callbacks to break retain cycles and allow the view to deallocate.
+            audioService.onStateChange = nil
+            audioService.onAudioLevelsUpdate = nil
+            transcriptionService.onTranscriptionComplete = nil
+            hotkeyService.onHotkeyPressed = nil
+        }
+        .onReceive(NotificationCenter.default.publisher(for: NSWindow.didBecomeKeyNotification)) { _ in
+            isWindowVisible = true
+        }
+        .onReceive(NotificationCenter.default.publisher(for: NSWindow.didResignKeyNotification)) { _ in
+            isWindowVisible = false
+        }
         .onChange(of: appState.settings.hotkeyEnabled) {
             setupHotkey()
         }
@@ -26,50 +40,101 @@ struct ContentView: View {
     
     private func setupServices() {
         // Set up audio service callbacks
-        audioService.onStateChange = { state in
-            appState.updateState(to: state)
+        audioService.onStateChange = { [weak appState] state in
+            appState?.updateState(to: state)
         }
         
-        audioService.onAudioLevelsUpdate = { levels in
-            appState.updateAudioLevels(levels)
+        audioService.onAudioLevelsUpdate = { [weak appState] levels in
+            appState?.updateAudioLevels(levels)
         }
         
-        // Set up transcription service callback
-        transcriptionService.onTranscriptionComplete = { result in
+        // Set up transcription service callback, capturing state objects weakly to prevent retain cycles.
+        transcriptionService.onTranscriptionComplete = { [weak appState, weak hotkeyService] result in
+            guard let appState = appState else { return }
             Task { @MainActor in
-                appState.debugInfo = "Debug: Transcription callback called!"
                 switch result {
                 case .success(let text):
-                    appState.debugInfo = "Debug: Got transcription: '\(text)' (length: \(text.count))"
-                    appState.setTranscribedText(text)
-                    appState.updateState(to: .idle)
+                    let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
+                    var isNonsense = false
                     
-                    // Always copy to clipboard
-                    hotkeyService.copyToClipboard(text)
-                    
-                    // If triggered by hotkey, paste after a delay to ensure proper focus
-                    if appState.wasTriggeredByHotkey {
-                        // Delay pasting to allow floating window to close and focus to return
-                        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
-                            hotkeyService.pasteToActiveWindow()
-                            
-                            // Reset the flag after pasting is complete
-                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
-                                appState.wasTriggeredByHotkey = false
-                            }
+                    if trimmed.count >= 8 {
+                        let chars = Array(trimmed)
+                        let repeated = chars[1]
+                        if chars[1...7].allSatisfy({ $0 == repeated }) {
+                            isNonsense = true
                         }
                     }
                     
+                    if trimmed.isEmpty || isNonsense {
+                        appState.lastTranscriptionSuccessful = false
+                        appState.transcribedText = "No speech detected"
+                        appState.updateState(to: .idle, message: "No speech detected")
+                    } else {
+                        appState.lastTranscriptionSuccessful = true
+                        appState.transcribedText = text
+                        appState.updateState(to: .idle)
+                        
+                        let pasteboard = NSPasteboard.general
+                        pasteboard.clearContents()
+                        pasteboard.setString(text, forType: .string)
+                        
+                        if appState.wasRecordingStartedByHotkey {
+                            hotkeyService?.setTextToPaste(text)
+                            hotkeyService?.pasteToActiveWindow()
+                        }
+                    }
                 case .failure(let error):
-                    appState.debugInfo = "Debug: Transcription failed: \(error)"
-                    appState.updateState(to: .idle, message: "Transcription failed: \(error.localizedDescription)")
+                    appState.lastTranscriptionSuccessful = false
+                    appState.updateState(to: .idle, message: "Error: \(error.localizedDescription)")
                 }
+                
+                appState.wasRecordingStartedByHotkey = false
             }
         }
         
-        // Set up hotkey callback
-        hotkeyService.onHotkeyPressed = {
-            handleHotkeyPressed()
+        // Set up hotkey callback, moving logic inside and capturing weakly to prevent retain cycles.
+        hotkeyService.onHotkeyPressed = { [weak appState, weak audioService, weak transcriptionService] in
+            guard let appState = appState else { return }
+            appState.wasRecordingStartedByHotkey = true
+            
+            if appState.currentState == .idle {
+                appState.lastTranscriptionSuccessful = false
+                guard appState.settings.isConfigured else {
+                    appState.showSettings = true
+                    return
+                }
+                Task {
+                    do {
+                        try await audioService?.startRecording()
+                    } catch {
+                        await MainActor.run {
+                            appState.updateState(to: .idle, message: "Recording failed: \(error.localizedDescription)")
+                        }
+                    }
+                }
+            } else if appState.currentState == .recording {
+                Task {
+                    do {
+                        guard let audioService = audioService,
+                              let transcriptionService = transcriptionService else { return }
+                        let audioData = try await audioService.stopRecording()
+                        
+                        await MainActor.run {
+                            appState.updateState(to: .transcribing)
+                        }
+                        
+                        try await transcriptionService.transcribe(
+                            audioData: audioData,
+                            apiKey: appState.settings.apiKey,
+                            model: appState.settings.selectedModel.rawValue
+                        )
+                    } catch {
+                        await MainActor.run {
+                            appState.updateState(to: .idle, message: "Failed to process recording: \(error.localizedDescription)")
+                        }
+                    }
+                }
+            }
         }
         
         // Validate setup on startup
@@ -86,87 +151,16 @@ struct ContentView: View {
             hotkeyService.unregisterHotkey()
         }
     }
-    
-    private func handleHotkeyPressed() {
-        // Mark that this was triggered by hotkey
-        appState.wasTriggeredByHotkey = true
-        
-        switch appState.currentState {
-        case .idle:
-            startRecording()
-        case .recording:
-            stopRecording()
-        case .transcribing:
-            // Do nothing while transcribing
-            break
-        }
-    }
-    
-    private func startRecording() {
-        appState.debugInfo = "Debug: Starting recording..."
-        guard appState.settings.isConfigured else {
-            appState.debugInfo = "Debug: Settings not configured"
-            appState.showSettings = true
-            return
-        }
-
-        Task {
-            do {
-                try await audioService.startRecording()
-                await MainActor.run {
-                    appState.debugInfo = "Debug: Recording started successfully"
-                }
-            } catch {
-                await MainActor.run {
-                    appState.debugInfo = "Debug: Recording failed: \(error)"
-                    appState.updateState(to: .idle, message: "Recording failed: \(error.localizedDescription)")
-                }
-            }
-        }
-    }
-    
-    private func stopRecording() {
-        Task {
-            do {
-                await MainActor.run {
-                    appState.debugInfo = "Debug: Stopping recording..."
-                }
-                let audioData = try await audioService.stopRecording()
-                
-                await MainActor.run {
-                    appState.updateState(to: .transcribing)
-                    appState.debugInfo = "Debug: Got \(audioData.count) bytes, transcribing..."
-                }
-                
-                // Transcribe the audio
-                try await transcriptionService.transcribe(
-                    audioData: audioData,
-                    apiKey: appState.settings.apiKey,
-                    model: appState.settings.selectedModel.rawValue
-                )
-                await MainActor.run {
-                    appState.debugInfo = "Debug: Transcription request sent, waiting for response..."
-                }
-                
-            } catch {
-                await MainActor.run {
-                    appState.debugInfo = "Debug: Recording/transcription failed: \(error)"
-                    appState.updateState(to: .idle, message: "Failed to process recording: \(error.localizedDescription)")
-                }
-            }
-        }
-    }
 }
 
 struct MainAppView: View {
     @ObservedObject var appState: AppStateModel
+    let isWindowVisible: Bool
     
     var body: some View {
         ZStack {
-            // Premium background with gradient and blur effects
             GeometryReader { geometry in
                 ZStack {
-                    // Base gradient background
                     LinearGradient(
                         gradient: Gradient(colors: [
                             Color(red: 0.4, green: 0.6, blue: 0.8).opacity(0.3),
@@ -177,7 +171,6 @@ struct MainAppView: View {
                         endPoint: .bottomTrailing
                     )
                     
-                    // Overlay blur effect
                     Rectangle()
                         .fill(.ultraThinMaterial)
                         .opacity(0.8)
@@ -185,72 +178,37 @@ struct MainAppView: View {
                 .ignoresSafeArea()
             }
             
-            VStack(spacing: 20) {
-                // Modern Header with Wolf Logo
+            VStack(spacing: 10) {
                 ModernHeaderView(appState: appState)
                 
-                // Central Recording Interface
-                VStack(spacing: 12) {
-                    // Glass-style Recording Button
+                VStack(spacing: 6) {
                     ModernRecordingButton(
                         state: appState.currentState,
                         isRecording: appState.currentState == .recording,
                         audioLevels: appState.audioLevels,
+                        appState: appState,
                         action: {
                             handleRecordingButtonTap(appState: appState)
                         }
                     )
                     
-                    // Status text with modern styling
                     Text(appState.statusText)
                         .font(.system(size: 18, weight: .medium, design: .rounded))
                         .foregroundStyle(.primary)
-                        .transition(.opacity.combined(with: .scale))
-                        .animation(.easeInOut(duration: 0.3), value: appState.statusText)
-                    
-                    // Show accessibility permission button if needed
-                    if appState.statusText.contains("Accessibility Access") {
-                        Button(action: {
-                            appState.requestAccessibilityPermission()
-                        }) {
-                            HStack(spacing: 8) {
-                                Image(systemName: "hand.raised.fill")
-                                    .font(.system(size: 14, weight: .medium))
-                                Text("Grant Accessibility Permission")
-                                    .font(.system(size: 14, weight: .medium))
-                            }
-                            .foregroundColor(.white)
-                            .padding(.horizontal, 16)
-                            .padding(.vertical, 10)
-                            .background(
-                                RoundedRectangle(cornerRadius: 8)
-                                    .fill(LinearGradient(
-                                        gradient: Gradient(colors: [Color.blue, Color.blue.opacity(0.8)]),
-                                        startPoint: .leading,
-                                        endPoint: .trailing
-                                    ))
-                            )
-                            .shadow(color: .blue.opacity(0.3), radius: 8, x: 0, y: 4)
-                        }
-                        .buttonStyle(PlainButtonStyle())
-                        .transition(.opacity.combined(with: .scale))
-                    }
+                        // .transition(.opacity.combined(with: .scale))
+                        // .animation(.easeInOut(duration: 0.3), value: appState.statusText)
                 }
                 
-                // Modern Transcription Panel
                 ModernTranscriptionPanel(text: appState.transcribedText)
                 
-                // Sleek Footer with Hotkey
                 ModernFooterView(appState: appState)
             }
-            .padding(.top, 15)
-            .padding(.horizontal, 25)
-            .padding(.bottom, 15)
+            .padding(.top, 4)
+            .padding(.horizontal, 17.5)
+            .padding(.bottom, 10.5)
         }
-        .frame(minWidth: 450, maxWidth: 600, minHeight: 500, maxHeight: 650)
+        .frame(width: 380, height: 420)
     }
-    
-
 }
 
 struct ModernHeaderView: View {
@@ -258,7 +216,6 @@ struct ModernHeaderView: View {
     
     var body: some View {
         HStack(alignment: .center, spacing: 16) {
-            // Modern Wolf Logo
             ZStack {
                 Circle()
                     .fill(.ultraThinMaterial)
@@ -271,9 +228,8 @@ struct ModernHeaderView: View {
                     .symbolRenderingMode(.hierarchical)
             }
             
-            // App Title with Modern Typography
             Text("WolfWhisper")
-                .font(.system(size: 28, weight: .semibold, design: .rounded))
+                .font(.system(size: 19.6, weight: .semibold, design: .rounded))
                 .foregroundStyle(.primary)
                 .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
             
@@ -283,23 +239,19 @@ struct ModernHeaderView: View {
     }
 }
 
-
-
-// Helper function to handle recording button tap
 @MainActor
 private func handleRecordingButtonTap(appState: AppStateModel) {
     switch appState.currentState {
     case .idle:
-        // Check if API key is configured
         guard appState.settings.isConfigured else {
             appState.showSettings = true
             return
         }
         
-        // Mark as NOT triggered by hotkey (button click)
         appState.wasTriggeredByHotkey = false
+        appState.wasRecordingStartedByHotkey = false
+        appState.lastTranscriptionSuccessful = false
         
-        // Start recording
         Task {
             do {
                 try await AudioService.shared.startRecording()
@@ -311,7 +263,6 @@ private func handleRecordingButtonTap(appState: AppStateModel) {
         }
         
     case .recording:
-        // Stop recording and transcribe
         Task {
             do {
                 let audioData = try await AudioService.shared.stopRecording()
@@ -320,7 +271,6 @@ private func handleRecordingButtonTap(appState: AppStateModel) {
                     appState.updateState(to: .transcribing)
                 }
                 
-                // Transcribe the audio
                 try await TranscriptionService.shared.transcribe(
                     audioData: audioData,
                     apiKey: appState.settings.apiKey,
@@ -335,49 +285,20 @@ private func handleRecordingButtonTap(appState: AppStateModel) {
         }
         
     case .transcribing:
-        // Do nothing while transcribing
         break
     }
 }
 
-
-
 struct ModernRecordingButton: View {
     let state: AppState
     let isRecording: Bool
     let audioLevels: [Float]
+    @ObservedObject var appState: AppStateModel
     let action: () -> Void
-    
-    @State private var isPressed = false
-    @State private var pulseScale: CGFloat = 1.0
-    @State private var glowOpacity: Double = 0.0
-    
+
     var body: some View {
         ZStack {
-            // Outer glow ring for recording state
-            if isRecording {
-                Circle()
-                    .stroke(
-                        LinearGradient(
-                            gradient: Gradient(colors: [
-                                Color.red.opacity(0.8),
-                                Color.orange.opacity(0.6),
-                                Color.red.opacity(0.4)
-                            ]),
-                            startPoint: .topLeading,
-                            endPoint: .bottomTrailing
-                        ),
-                        lineWidth: 3
-                    )
-                    .frame(width: 130, height: 130)
-                    .scaleEffect(pulseScale)
-                    .opacity(glowOpacity)
-                    .blur(radius: 2)
-            }
-            
-            // Main glassmorphic button
             ZStack {
-                // Glass background
                 Circle()
                     .fill(.ultraThinMaterial)
                     .frame(width: 100, height: 100)
@@ -387,64 +308,34 @@ struct ModernRecordingButton: View {
                     )
                     .shadow(color: .black.opacity(0.15), radius: 20, x: 0, y: 10)
                     .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
-                
-                // Content based on state
+
                 Group {
                     switch state {
                     case .idle:
-                        ModernIdleContent()
+                        if appState.transcribedText.isEmpty {
+                            ModernIdleContent()
+                        } else {
+                            ModernCompletedContent()
+                        }
                     case .recording:
-                        ModernRecordingContent(audioLevels: audioLevels)
+                        ModernRecordingContent(audioLevels: audioLevels, appState: appState, isWindowVisible: true)
                     case .transcribing:
-                        ModernTranscribingContent()
+                        ModernTranscribingContentNew(appState: appState, isWindowVisible: true)
                     }
                 }
             }
         }
-        .scaleEffect(isPressed ? 0.95 : 1.0)
         .onTapGesture {
-            // Add haptic feedback
             NSHapticFeedbackManager.defaultPerformer.perform(.alignment, performanceTime: .now)
             action()
         }
-        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity, perform: {}, onPressingChanged: { pressing in
-            withAnimation(.easeInOut(duration: 0.1)) {
-                isPressed = pressing
-            }
-        })
-        .onAppear {
-            if isRecording {
-                startRecordingAnimation()
-            }
-        }
-        .onChange(of: isRecording) { _, recording in
-            if recording {
-                startRecordingAnimation()
-            } else {
-                stopRecordingAnimation()
-            }
-        }
-    }
-    
-    private func startRecordingAnimation() {
-        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
-            pulseScale = 1.2
-            glowOpacity = 0.8
-        }
-    }
-    
-    private func stopRecordingAnimation() {
-        withAnimation(.easeInOut(duration: 0.3)) {
-            pulseScale = 1.0
-            glowOpacity = 0.0
-        }
     }
 }
 
 struct ModernIdleContent: View {
     var body: some View {
         Image(systemName: "mic.fill")
-            .font(.system(size: 32, weight: .medium))
+            .font(.system(size: 33.6, weight: .medium))
             .foregroundStyle(.white)
             .symbolRenderingMode(.hierarchical)
     }
@@ -452,127 +343,44 @@ struct ModernIdleContent: View {
 
 struct ModernRecordingContent: View {
     let audioLevels: [Float]
-    @State private var waveAnimation: Bool = false
-    
+    @ObservedObject var appState: AppStateModel
+    let isWindowVisible: Bool
     var body: some View {
         ZStack {
-            // Animated waveform background
-            ForEach(0..<3, id: \.self) { index in
-                Circle()
-                    .stroke(.white.opacity(0.3), lineWidth: 2)
-                    .frame(width: CGFloat(40 + index * 15), height: CGFloat(40 + index * 15))
-                    .scaleEffect(waveAnimation ? 1.2 : 0.8)
-                    .opacity(waveAnimation ? 0.0 : 0.6)
-                    .animation(
-                        .easeInOut(duration: 1.5)
-                        .repeatForever(autoreverses: false)
-                        .delay(Double(index) * 0.3),
-                        value: waveAnimation
-                    )
+            Circle()
+                .fill(Color.white.opacity(0.1))
+                .frame(width: 70, height: 70)
+            if appState.currentState == .recording && isWindowVisible {
+                MiniWaveVisualizer(audioLevels: audioLevels, isActive: true)
+            } else {
+                MiniWaveVisualizer(audioLevels: audioLevels, isActive: false)
             }
-            
-            Image(systemName: "waveform")
-                .font(.system(size: 28, weight: .medium))
-                .foregroundStyle(.white)
-                .symbolRenderingMode(.hierarchical)
-        }
-        .onAppear {
-            waveAnimation = true
         }
     }
 }
 
-struct ModernTranscribingContent: View {
-    @State private var rotationAngle: Double = 0
-    @State private var pulseScale: CGFloat = 1.0
-    @State private var nodeOpacity: Double = 0.5
-    
+struct ModernTranscribingContentNew: View {
+    @ObservedObject var appState: AppStateModel
+    let isWindowVisible: Bool
     var body: some View {
-        ZStack {
-            // Outer ring
-            Circle()
-                .stroke(
-                    LinearGradient(
-                        colors: [Color.cyan.opacity(0.8), Color.blue.opacity(0.6)],
-                        startPoint: .topLeading,
-                        endPoint: .bottomTrailing
-                    ),
-                    lineWidth: 3
-                )
-                .frame(width: 70, height: 70)
-                .rotationEffect(.degrees(rotationAngle))
-            
-            // Middle ring
-            Circle()
-                .stroke(
-                    LinearGradient(
-                        colors: [Color.blue.opacity(0.6), Color.purple.opacity(0.4)],
-                        startPoint: .topLeading,
-                        endPoint: .bottomTrailing
-                    ),
-                    lineWidth: 2
-                )
-                .frame(width: 55, height: 55)
-                .rotationEffect(.degrees(-rotationAngle * 0.7))
-            
-            // Inner ring
-            Circle()
-                .stroke(Color.purple.opacity(0.4), lineWidth: 1.5)
-                .frame(width: 40, height: 40)
-                .rotationEffect(.degrees(rotationAngle * 1.3))
-            
-            // Processing nodes
-            ForEach(0..<6, id: \.self) { node in
-                Circle()
-                    .fill(Color.cyan)
-                    .frame(width: 4, height: 4)
-                    .offset(
-                        x: cos(Double(node) * .pi / 3) * 25,
-                        y: sin(Double(node) * .pi / 3) * 25
-                    )
-                    .rotationEffect(.degrees(rotationAngle * 0.5))
-                    .opacity(nodeOpacity)
-            }
-            
-            // Central brain
+        VStack(spacing: 8) {
             ZStack {
-                RoundedRectangle(cornerRadius: 8)
-                    .fill(Color.white)
-                    .frame(width: 28, height: 22)
-                    .scaleEffect(pulseScale)
-                
-                Image(systemName: "brain")
-                    .font(.system(size: 16, weight: .medium))
-                    .foregroundColor(.cyan)
-                    .scaleEffect(pulseScale)
+                Circle()
+                    .fill(Color.white.opacity(0.1))
+                    .frame(width: 70, height: 70)
+                MiniTranscribingVisualizer(isActive: appState.currentState == .transcribing && isWindowVisible)
             }
-        }
-        .onAppear {
-            startAnimations()
-        }
-    }
-    
-    private func startAnimations() {
-        withAnimation(.linear(duration: 4).repeatForever(autoreverses: false)) {
-            rotationAngle = 360
-        }
-        
-        withAnimation(.easeInOut(duration: 1.2).repeatForever(autoreverses: true)) {
-            pulseScale = 1.15
-        }
-        
-        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
-            nodeOpacity = 1.0
+            Text("Transcribing... The result will be copied to your clipboard.")
+                .font(.system(size: 13, weight: .medium, design: .rounded))
+                .foregroundStyle(.secondary)
+                .multilineTextAlignment(.center)
+                .padding(.top, 2)
         }
     }
 }
 
-
-
 struct ModernTranscriptionPanel: View {
     let text: String
-    @State private var animateText = false
-    
     var body: some View {
         RoundedRectangle(cornerRadius: 20)
             .fill(.thinMaterial)
@@ -585,35 +393,28 @@ struct ModernTranscriptionPanel: View {
             .overlay(
                 Group {
                     if text.isEmpty {
-                        // Empty state with elegant placeholder
                         VStack(spacing: 16) {
                             Image(systemName: "quote.bubble")
                                 .font(.system(size: 32, weight: .light))
                                 .foregroundStyle(.secondary)
                                 .symbolRenderingMode(.hierarchical)
-                            
                             Text("No transcription yet")
-                                .font(.system(size: 16, weight: .medium, design: .rounded))
+                                .font(.system(size: 12.6, weight: .medium, design: .rounded))
                                 .foregroundStyle(.secondary)
                         }
-                        .transition(.opacity.combined(with: .scale))
                     } else {
-                        // Transcribed text with typing animation
                         ScrollView {
                             Text(text)
-                                .font(.system(size: 16, weight: .regular, design: .rounded))
+                                .font(.system(size: 12.6, weight: .regular, design: .rounded))
                                 .foregroundStyle(.primary)
                                 .lineSpacing(4)
                                 .padding(20)
                                 .frame(maxWidth: .infinity, alignment: .leading)
-                                .transition(.opacity.combined(with: .move(edge: .bottom)))
                         }
-                        .animation(.easeInOut(duration: 0.5), value: text)
                     }
                 }
             )
             .frame(height: 150)
-            .animation(.easeInOut(duration: 0.3), value: text.isEmpty)
     }
 }
 
@@ -623,14 +424,12 @@ struct ModernFooterView: View {
     var body: some View {
         if appState.settings.hotkeyEnabled {
             HStack(spacing: 12) {
-                // Hotkey label with icon
                 Label("Global Hotkey:", systemImage: "keyboard")
-                    .font(.system(size: 14, weight: .medium, design: .rounded))
+                    .font(.system(size: 12.6, weight: .medium, design: .rounded))
                     .foregroundStyle(.secondary)
                 
-                // Modern hotkey display
                 Text(formatHotkeyDisplay(appState.settings.hotkeyDisplay))
-                    .font(.system(size: 16, weight: .semibold, design: .monospaced))
+                    .font(.system(size: 12.6, weight: .semibold, design: .monospaced))
                     .foregroundStyle(.primary)
                     .padding(.horizontal, 12)
                     .padding(.vertical, 6)
@@ -649,12 +448,11 @@ struct ModernFooterView: View {
                     .stroke(.white.opacity(0.2), lineWidth: 1)
             )
             .shadow(color: .black.opacity(0.08), radius: 8, x: 0, y: 3)
-            .transition(.opacity.combined(with: .scale))
+            // .transition(.opacity.combined(with: .scale))
         }
     }
     
     private func formatHotkeyDisplay(_ display: String) -> String {
-        // Convert the display to use proper symbols
         return display
             .replacingOccurrences(of: "Cmd", with: "⌘")
             .replacingOccurrences(of: "Shift", with: "⇧")
@@ -664,6 +462,300 @@ struct ModernFooterView: View {
     }
 }
 
+struct ModernCompletedContent: View {
+    @State private var showMicrophoneIcon = false
+    @State private var animationTask: DispatchWorkItem?
+    var body: some View {
+        ZStack {
+            Circle()
+                .fill(Color.white.opacity(0.1))
+                .frame(width: 70, height: 70)
+            if showMicrophoneIcon {
+                Image(systemName: "mic.fill")
+                    .font(.system(size: 33.6, weight: .medium))
+                    .foregroundStyle(.white)
+                    .symbolRenderingMode(.hierarchical)
+                    .transition(.opacity.combined(with: .scale))
+            } else {
+                MiniClipboardVisualizer()
+                    .scaleEffect(2.5)
+            }
+        }
+        .onAppear(perform: setupAnimations)
+        .onDisappear(perform: cancelAnimations)
+    }
+    private func setupAnimations() {
+        showMicrophoneIcon = false
+        let task = DispatchWorkItem {
+            withAnimation(.easeInOut(duration: 0.5)) {
+                self.showMicrophoneIcon = true
+            }
+        }
+        self.animationTask = task
+        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0, execute: task)
+    }
+    private func cancelAnimations() {
+        animationTask?.cancel()
+    }
+}
+
+struct MiniWaveVisualizer: View {
+    let audioLevels: [Float]
+    let isActive: Bool
+    private let barCount = 16
+    private let barSpacing: CGFloat = 1.5
+    var body: some View {
+        if isActive {
+            TimelineView(.animation) { timeline in
+                let currentTime = timeline.date.timeIntervalSinceReferenceDate
+                HStack(spacing: barSpacing) {
+                    ForEach(0..<barCount, id: \.self) { index in
+                        MiniWaveformBar(
+                            index: index,
+                            barCount: barCount,
+                            audioLevels: audioLevels,
+                            time: currentTime
+                        )
+                    }
+                }
+            }
+        } else {
+            HStack(spacing: barSpacing) {
+                ForEach(0..<barCount, id: \.self) { _ in
+                    RoundedRectangle(cornerRadius: 1)
+                        .fill(Color.gray.opacity(0.3))
+                        .frame(width: 2, height: 2)
+                }
+            }
+        }
+    }
+}
+
+struct MiniWaveformBar: View {
+    let index: Int
+    let barCount: Int
+    let audioLevels: [Float]
+    let time: Double
+    
+    private var barWidth: CGFloat {
+        2.0
+    }
+    
+    private var audioLevel: Float {
+        let audioIndex = Int(Float(index) / Float(barCount) * Float(audioLevels.count))
+        if audioIndex < audioLevels.count {
+            return audioLevels[audioIndex]
+        }
+        return 0.0
+    }
+    
+    private var animatedHeight: CGFloat {
+        let maxHeight: CGFloat = 24
+        let baseHeight = CGFloat(audioLevel) * maxHeight
+        let animationOffset = Darwin.sin(time * 4 + Double(index) * 0.3) * 2
+        return max(2, baseHeight + animationOffset)
+    }
+    
+    private var rainbowColor: Color {
+        let normalizedPosition = Double(index) / Double(barCount - 1)
+        let hue = 0.8 - (normalizedPosition * 0.8)
+        
+        return Color(
+            hue: hue,
+            saturation: 0.8 + Double(audioLevel) * 0.2,
+            brightness: 0.7 + Double(audioLevel) * 0.3
+        )
+    }
+    
+    var body: some View {
+        VStack {
+            Spacer()
+            
+            RoundedRectangle(cornerRadius: barWidth / 2)
+                .fill(
+                    LinearGradient(
+                        colors: [
+                            rainbowColor.opacity(0.9),
+                            rainbowColor.opacity(0.7),
+                            rainbowColor.opacity(0.5)
+                        ],
+                        startPoint: .top,
+                        endPoint: .bottom
+                    )
+                )
+                .frame(width: barWidth, height: animatedHeight)
+                .shadow(color: rainbowColor.opacity(0.3), radius: 1, x: 0, y: 0.5)
+                // .animation(.easeOut(duration: 0.05), value: Double(audioLevel))
+            
+            Spacer()
+        }
+        .frame(height: 24)
+    }
+}
+
+struct MiniTranscribingVisualizer: View {
+    let isActive: Bool
+    private let barCount = 16
+    private let barSpacing: CGFloat = 1.5
+    var body: some View {
+        if isActive {
+            TimelineView(.animation) { timeline in
+                let currentTime = timeline.date.timeIntervalSinceReferenceDate
+                HStack(spacing: barSpacing) {
+                    ForEach(0..<barCount, id: \.self) { index in
+                        MiniTranscribingBar(
+                            index: index,
+                            barCount: barCount,
+                            time: currentTime
+                        )
+                    }
+                }
+            }
+        } else {
+            HStack(spacing: barSpacing) {
+                ForEach(0..<barCount, id: \.self) { _ in
+                    RoundedRectangle(cornerRadius: 1)
+                        .fill(Color.gray.opacity(0.3))
+                        .frame(width: 2, height: 2)
+                }
+            }
+        }
+    }
+}
+
+struct MiniTranscribingBar: View {
+    let index: Int
+    let barCount: Int
+    let time: Double
+    
+    private var barWidth: CGFloat {
+        2.0
+    }
+    
+    private var animatedHeight: CGFloat {
+        let maxHeight: CGFloat = 24
+        let minHeight: CGFloat = 0.5
+        
+        let waveOffset = time * 2
+        let indexOffset = Double(index) * 0.4
+        
+        let primaryWave = Darwin.sin(waveOffset + indexOffset) * 0.5
+        let secondaryWave = Darwin.sin(waveOffset * 1.5 + indexOffset * 0.7) * 0.4
+        
+        let combinedWave = primaryWave + secondaryWave
+        let normalizedHeight = (combinedWave + 1) / 2
+        
+        let heightRange = maxHeight - minHeight
+        return minHeight + (normalizedHeight * heightRange)
+    }
+    
+    private var rainbowColor: Color {
+        let normalizedPosition = Double(index) / Double(barCount - 1)
+        let timeOffset = time * 0.5
+        let hue = fmod(0.8 - (normalizedPosition * 0.8) + timeOffset, 1.0)
+        
+        return Color(
+            hue: hue,
+            saturation: 0.8,
+            brightness: 0.8
+        )
+    }
+    
+    var body: some View {
+        VStack {
+            Spacer()
+            
+            RoundedRectangle(cornerRadius: barWidth / 2)
+                .fill(
+                    LinearGradient(
+                        colors: [
+                            rainbowColor.opacity(0.9),
+                            rainbowColor.opacity(0.7),
+                            rainbowColor.opacity(0.5)
+                        ],
+                        startPoint: .top,
+                        endPoint: .bottom
+                    )
+                )
+                .frame(width: barWidth, height: animatedHeight)
+                .shadow(color: rainbowColor.opacity(0.3), radius: 1, x: 0, y: 0.5)
+            
+            Spacer()
+        }
+        .frame(height: 24)
+    }
+}
+
+struct MiniClipboardVisualizer: View {
+    @State private var showCompleted = false
+    @State private var pulseScale: CGFloat = 1.0
+    @State private var animationTask: DispatchWorkItem?
+
+    var body: some View {
+        ZStack {
+            if showCompleted {
+                Image(systemName: "checkmark.circle.fill")
+                    .font(.system(size: 14, weight: .medium))
+                    .foregroundStyle(
+                        LinearGradient(
+                            colors: [
+                                Color.blue.opacity(0.8),
+                                Color.cyan.opacity(0.6)
+                            ],
+                            startPoint: .topLeading,
+                            endPoint: .bottomTrailing
+                        )
+                    )
+                    .scaleEffect(pulseScale)
+                    .shadow(color: Color.blue.opacity(0.2), radius: 2, x: 0, y: 1)
+            } else {
+                ZStack {
+                    Circle()
+                        .fill(
+                            RadialGradient(
+                                colors: [
+                                    Color.blue.opacity(0.3),
+                                    Color.blue.opacity(0.1),
+                                    Color.clear
+                                ],
+                                center: .center,
+                                startRadius: 0,
+                                endRadius: 12
+                            )
+                        )
+                        .frame(width: 24, height: 24)
+                        .scaleEffect(pulseScale)
+                    
+                    Image(systemName: "clipboard")
+                        .font(.system(size: 12, weight: .medium))
+                        .foregroundColor(.blue)
+                        .scaleEffect(pulseScale)
+                }
+            }
+        }
+        .onAppear(perform: startAnimation)
+        .onDisappear(perform: cancelAnimation)
+    }
+    
+    private func startAnimation() {
+        withAnimation(.easeInOut(duration: 0.4)) {
+            pulseScale = 1.2
+        }
+        let task = DispatchWorkItem {
+            withAnimation(.easeInOut(duration: 0.3)) {
+                self.showCompleted = true
+                self.pulseScale = 1.0
+            }
+        }
+        self.animationTask = task
+        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: task)
+    }
+    
+    private func cancelAnimation() {
+        animationTask?.cancel()
+    }
+}
+
 #Preview {
     ContentView(appState: AppStateModel())
 } 
\ No newline at end of file
